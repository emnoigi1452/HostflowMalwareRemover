package haizivs.hostflowmalwareremover;

import lombok.Cleanup;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.TypeInsnNode;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;

public class HostflowRemover {

    private static final String PREFIX = "[HostflowMalwareRemover] ";

    private final ArrayList<Path> infectedFiles = new ArrayList<>();

    public static void main(String[] args) {
        Path plugins = FileSystems.getDefault().getPath("plugins");
        if (Files.exists(plugins)) {
            new HostflowRemover(plugins);
        } else {
            System.out.println(PREFIX + "Could not find 'plugins' directory.");
        }
    }

    public HostflowRemover(Path pluginsPath) {
        try {
            Files.walk(pluginsPath).forEach(path -> scanFile(path.toFile()));

            if (!infectedFiles.isEmpty()) {
                System.err.println(PREFIX + String.format("Found %d plugins with malware. Removing...", infectedFiles.size()));

                File pluginsFile = pluginsPath.toFile();
                File quarantine = new File(pluginsFile, "malware-quarantine");
                if (!quarantine.exists() && !quarantine.mkdir()) {
                    System.err.println("Could not create plugins/malware-quarantine folder.");
                    return;
                }

                for (Path path : infectedFiles) {
                    File file = path.toFile();
                    File from = new File(quarantine, file.getName());
                    File to = new File(pluginsFile, file.getName());
                    if (!file.renameTo(from)) {
                        System.err.println(PREFIX + String.format("Could not move infected plugin (%s) to quarantine.", file.getName()));
                        return;
                    }

                    System.out.println(PREFIX + "Removing malware from " + from.getName() + "...");
                    try {
                        runRemover(from, to);
                    } catch (Throwable e) {
                        e.printStackTrace();
                        System.err.println(PREFIX + "Could not remove malware from " + from.getName() + ".");
                    }
                }
            } else {
                System.out.println(PREFIX + "No plugins with malware were found.");
            }
            System.out.println(PREFIX + "Done!");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void scanFile(File file) {
        if (file.isDirectory()) {
            return;
        }

        String fileName = file.getName();
        if (!fileName.endsWith(".jar")) {
            return;
        }

        try {
            @Cleanup ZipFile zip = new ZipFile(file);
            Enumeration<? extends ZipEntry> entries = zip.entries();
            while (entries.hasMoreElements()) {
                ZipEntry zipEntry = entries.nextElement();
                zipEntry.setCompressedSize(-1);
                if (zipEntry.getName().equals("javassist/PingMessage.class")
                        || zipEntry.getName().equals("javassist/ResponseContainer.class")
                || zipEntry.getName().startsWith("skz15/")) {
                    infectedFiles.add(file.toPath());
                    break;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            System.err.println(PREFIX + "Failed to scan " + fileName);
        }
    }

    private void runRemover(File from, File to) throws Exception {
        ArrayList<String> ignoreOnOutput = new ArrayList<>();
        ignoreOnOutput.add("skz15/Franslator.class");
        @Cleanup ZipOutputStream out = new ZipOutputStream(new FileOutputStream(to));
        @Cleanup ZipFile zipFile = new ZipFile(from);

        Enumeration<? extends ZipEntry> entries = zipFile.entries();
        while (entries.hasMoreElements()) {
            ZipEntry zipEntry = entries.nextElement();
            zipEntry.setCompressedSize(-1);
            if (zipEntry.getName().endsWith("module-info.class")) {
                continue;
            }

            String entryName = zipEntry.getName();

            if(entryName.startsWith("javassist") || entryName.contains("skz15"))
                continue;

            if (!entryName.endsWith(".class")) {
                if (entryName.equals(".l1") ||
                        entryName.equals(".l_ignore") ||
                        entryName.startsWith("javassist/") ||
                        entryName.startsWith("skz15/") ||
                        entryName.equals(".la_gnita") ||
                        entryName.equals(".data")) {
                    continue;
                }
                out.putNextEntry(zipEntry);
                FileUtils.writeToFile(out, zipFile.getInputStream(zipEntry));
                continue;
            }

            @Cleanup InputStream in = zipFile.getInputStream(zipEntry);

            if(in.available() <= 0)
                continue;

            ClassReader cr = new ClassReader(in);
            ClassNode classNode = new ClassNode();
            cr.accept(classNode, 0);

            System.out.println("Processing main class > " + zipEntry.getName());
            for (MethodNode mn : classNode.methods) {

                //System.out.println("Inspecting method > " + mn.name);

                if (!mn.name.equals("onEnable")) {
                    continue;
                }

                //System.out.println("Processing instructions...");

                List<AbstractInsnNode> remove = new CopyOnWriteArrayList<>();
                int constructor = 0xbb;
                for (AbstractInsnNode insn : mn.instructions) {
                   // System.out.println("Instruction type: " + insn.getClass().getSimpleName() +
                            //" -> Constructor = " + (insn.getOpcode() == constructor));
                    if (!(insn instanceof TypeInsnNode)) {
                        continue;
                    }
                    TypeInsnNode tinsn = (TypeInsnNode) insn;
                    if (tinsn.desc.equals(classNode.name + "L10")) {
                        System.out.println("Detected L10 constructor in bytecode!");
                        ignoreOnOutput.add(classNode.name + "L10.class");
                        remove.add(insn);
                        for(int i = 1; i <= 6; i++) {
                            try {
                                remove.add(AsmUtils.getNext(insn, i));
                            } catch(Throwable t) {  }
                        }
                    } else if(tinsn.desc.startsWith("skz15/")) {
                        System.out.println("Detected skz15 constructor in bytecode!");
                        remove.add(insn);
                        for(int i = 1; i <= 3; i++) {
                            try {
                                remove.add(AsmUtils.getNext(insn, i));
                            } catch(Throwable t) {  }
                        }
                    }
                }
                remove.forEach(ainsn -> {
                    mn.instructions.remove(ainsn);
                });
            }

            ClassWriter cw = new ClassWriter(1);
            classNode.accept(cw);

            ZipEntry newEntry = new ZipEntry(entryName);
            if (!ignoreOnOutput.contains(entryName) && !entryName.startsWith("javassist/") && !entryName.startsWith("skz15/")) {
                out.putNextEntry(newEntry);
                @Cleanup ByteArrayInputStream bais = new ByteArrayInputStream(cw.toByteArray());
                FileUtils.writeToFile(out, bais);
            }
        }
    }

}
