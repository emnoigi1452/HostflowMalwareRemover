package haizivs.hostflowmalwareremover;

import lombok.Cleanup;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.TypeInsnNode;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;

public class HostflowRemover {

    private static final String PREFIX = "[HostflowMalwareRemover] ";

    public static final ExecutorService service = Executors.newScheduledThreadPool(256);

    private final ArrayList<Path> infectedFiles = new ArrayList<>();

    public static void main(String[] args) {
        Path plugins = FileSystems.getDefault().getPath("plugins");
        if (Files.exists(plugins)) {
            new HostflowRemover(plugins);
        } else {
            System.out.println(PREFIX + "Could not find 'plugins' directory.");
        }
        Runtime.getRuntime().addShutdownHook(new Thread(service::shutdown));
    }

    public HostflowRemover(Path pluginsPath) {
        try {
            Files.walk(pluginsPath).forEach(path -> scanFile(path.toFile()));

            List<Future<?>> tasks = new ArrayList<>();

            if (!infectedFiles.isEmpty()) {
                System.err.println(PREFIX + String.format("Found %d plugins with malware. Removing...", infectedFiles.size()));

                File pluginsFile = pluginsPath.toFile();
                File quarantine = new File(pluginsFile, "malware-quarantine");
                if (!quarantine.exists() && !quarantine.mkdir()) {
                    System.err.println("Could not create plugins/malware-quarantine folder.");
                    return;
                }

                final AtomicBoolean begin = new AtomicBoolean(false);

                for (Path path : infectedFiles) {
                    File file = path.toFile();
                    File from = new File(quarantine, file.getName());
                    File to = new File(pluginsFile, file.getName());
                    if (!file.renameTo(from)) {
                        System.err.println(PREFIX + String.format("Could not move infected plugin (%s) to quarantine.", file.getName()));
                        return;
                    }

                    System.out.println(PREFIX + "Begin removing malware from " + from.getName() + "...");
                    try {
                        Future<?> malwareRemoverTask = service.submit(() -> {
                            try {
                                while(!begin.get())
                                    Thread.sleep(3000L);
                                runRemover(from, to);
                            } catch (Exception e) {
                                throw new RuntimeException(e);
                            }
                        });
                        tasks.add(malwareRemoverTask);
                    } catch (Throwable e) {
                        e.printStackTrace();
                        System.err.println(PREFIX + "Could not remove malware from " + from.getName() + ".");
                    }
                }
                begin.set(true);
            } else {
                System.out.println(PREFIX + "No plugins with malware were found.");
            }

            for(Future<?> runningTasks: tasks)
                runningTasks.get();
            System.out.println(PREFIX + "Done!");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void scanFile(File file) {
        if (file.isDirectory()) {
            return;
        }

        String fileName = file.getName();
        if (!fileName.endsWith(".jar")) {
            return;
        }

        try {
            @Cleanup ZipFile zip = new ZipFile(file);
            Enumeration<? extends ZipEntry> entries = zip.entries();
            while (entries.hasMoreElements()) {
                ZipEntry zipEntry = entries.nextElement();
                zipEntry.setCompressedSize(-1);
                if (zipEntry.getName().equals("javassist/PingMessage.class")
                        || zipEntry.getName().equals("javassist/ResponseContainer.class")
                || zipEntry.getName().startsWith("skz15/")) {
                    infectedFiles.add(file.toPath());
                    break;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            System.err.println(PREFIX + "Failed to scan " + fileName);
        }
    }

    private void runRemover(File from, File to) throws Exception {
        ArrayList<String> ignoreOnOutput = new ArrayList<>();
        ignoreOnOutput.add("skz15/Franslator.class");
        @Cleanup ZipOutputStream out = new ZipOutputStream(new FileOutputStream(to));
        @Cleanup ZipFile zipFile = new ZipFile(from);

        StringBuilder statusBuilder = new StringBuilder();

        Enumeration<? extends ZipEntry> entries = zipFile.entries();
        int entryCount = 0;
        while (entries.hasMoreElements()) {
            ZipEntry zipEntry = entries.nextElement();
            zipEntry.setCompressedSize(-1);
            if (zipEntry.getName().endsWith("module-info.class")) {
                continue;
            }

            String entryName = zipEntry.getName();

            if(entryName.startsWith("javassist") || entryName.contains("skz15"))
                continue;

            if (!entryName.endsWith(".class")) {
                if (entryName.equals(".l1") ||
                        entryName.equals(".l_ignore") ||
                        entryName.startsWith("javassist/") ||
                        entryName.startsWith("skz15/") ||
                        entryName.equals(".la_gnita") ||
                        entryName.equals(".data")) {
                    continue;
                }
                out.putNextEntry(zipEntry);
                FileUtils.writeToFile(out, zipFile.getInputStream(zipEntry));
                continue;
            }

            @Cleanup InputStream in = zipFile.getInputStream(zipEntry);

            if(in.available() <= 0)
                continue;

            ClassReader cr = new ClassReader(in);
            ClassNode classNode = new ClassNode();
            cr.accept(classNode, 0);

            entryCount++;

            for (MethodNode mn : classNode.methods) {

                //System.out.println("Inspecting method > " + mn.name);

                if (!mn.name.equals("onEnable")) {
                    continue;
                }

                //System.out.println("Processing instructions...");

                List<AbstractInsnNode> remove = new CopyOnWriteArrayList<>();
                int constructor = 0xbb;
                for (AbstractInsnNode insn : mn.instructions) {
                   // System.out.println("Instruction type: " + insn.getClass().getSimpleName() +
                            //" -> Constructor = " + (insn.getOpcode() == constructor));
                    if (!(insn instanceof TypeInsnNode)) {
                        continue;
                    }
                    TypeInsnNode tinsn = (TypeInsnNode) insn;
                    if (tinsn.desc.equals(classNode.name + "L10")) {
                        statusBuilder.append("Detected L10 constructor in bytecode! Class: " + zipEntry.getName()).append("\n");
                        ignoreOnOutput.add(classNode.name + "L10.class");
                        remove.add(insn);
                        for(int i = 1; i <= 6; i++) {
                            try {
                                remove.add(AsmUtils.getNext(insn, i));
                            } catch(Throwable t) {  }
                        }
                    } else if(tinsn.desc.startsWith("skz15/")) {
                        statusBuilder.append("Detected skz15 constructor in bytecode! Class: " + zipEntry.getName()).append("\n");
                        remove.add(insn);
                        for(int i = 1; i <= 3; i++) {
                            try {
                                remove.add(AsmUtils.getNext(insn, i));
                            } catch(Throwable t) {  }
                        }
                    }
                }
                remove.forEach(ainsn -> {
                    mn.instructions.remove(ainsn);
                });
            }

            ClassWriter cw = new ClassWriter(1);
            classNode.accept(cw);

            ZipEntry newEntry = new ZipEntry(entryName);
            if (!ignoreOnOutput.contains(entryName) && !entryName.startsWith("javassist/") && !entryName.startsWith("skz15/")) {
                out.putNextEntry(newEntry);
                @Cleanup ByteArrayInputStream bais = new ByteArrayInputStream(cw.toByteArray());
                FileUtils.writeToFile(out, bais);
            }
        }
        statusBuilder.append("Finished patching > " + to.getName() + " - Scanned: " + entryCount + " classes");
        synchronized (System.out) {
            System.out.println(statusBuilder);
            System.out.println("-----------------------------------");
        }
        System.gc();
        System.runFinalization();
    }

}
